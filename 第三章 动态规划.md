#动态规划 #算法
# 背景知识 
通过组合子问题的解来求解原问题
分治法：互不相交的子问题，递归求解子问题，如果子问题有重叠，递归会反复求解子问题，效率下降
动态规划：避免子问题重叠的情况，动态规划对这样的工工资问题只求解一次，将其保存在起来，再次碰到无需重新计算，直接复用即可
# 3.1 钢条切割问题
## 1. 问题引入
如果长度为 n 英寸的钢条的价格 pn 足够大，则可能完全不需要切割，出售整条钢条是最好的收益。但由于每个 pi 不同，可能切割后出售会更好一些。我们要找的是一个最大化销售收益的方案。
![[Pasted image 20230509103558.png]]
## 2. 求解
### 普通的递归求解
只需保证每一次切割都是最优切割，最后的收益一定最大。有一般的，我们有
![[Pasted image 20230509103931.png]]
为简化问题，我们将钢条从左边切割下长度为 i 的一段，然后只对右边剩下的长度为 n-i 的一段继续切割，进行递归求解。此时有
![[Pasted image 20230509104408.png]]
则自顶向下的递归求解过程伪代码：
![[Pasted image 20230509104439.png]]
此种方法考察了所有切割方案，复杂度为指数级。
### 动态规划求解
以空间换时间，将指数复杂度降为多项式时间的解
1. 带备忘的自顶向下法
 对比上面的递归求解，在计算最大切割时，此处只是加了一个判断某方案的值是否被求过，如果已经求过，则直接返回，避免了大量的重复递归过程，从而降低了复杂度。
 ![[Pasted image 20230509105143.png]]
 ![[Pasted image 20230509105135.png]]

2. 自底向上
用到的 r[j-i]被直接得出，不必再计算
![[Pasted image 20230509105548.png]]
3. 复杂度
二者的复杂度都为 $\Theta(n^2)$
## 3. 最优子结构
最优子结构性是指一个问题的最优解可以通过利用子问题的最优解来得到。如果一个问题具有最优子结构性质，我们就可以通过动态规划等方法对其进行求解。

如果一个问题的最优解包含其子问题的最优解，那么该问题就具有最优子结构。例如，假设我们需要找到一个长度为 n 的序列的最长递增子序列，如果我们能够找到长度为 i 的子序列的最长递增子序列，那么我们就能够通过扩展这个子序列来获得长度为 i+1的子序列的最长递增子序列。因此，最长递增子序列问题具有最优子结构。如果一个问题不具有最优子结构，那么我们通常无法使用动态规划算法对其进行求解，而需要使用其他的方法。


## 4. 子问题图
- 用于描述子问题与子问题间的依赖关系：若求子问题 x 的最优解时需要直接用到子问题 y 的最优解，则在子问题图中就会有一条从子问题 x 的顶点到子问题 y 的顶点的有向边。 
- 图为 n=4 钢条切割问题的子问题图。它是自顶向下递归树的简化版。树中所有对应相同子问题的节点合并为单一顶点。
![[Pasted image 20230509110426.png]] 
- 对于任何子问题，仅当它依赖的所有子问题都求解完成了，才会求解它。
- 自顶向下的动态规划方法处理子问题图中顶点的顺序为：深度优先搜索
- 自底向上则是逆拓扑序
- 子问题数等于子问题图定点数，动态规划算法时间与顶点和边数呈线性关系。

## 5. 解重构
主要是求出切割方案，过程很简单，添加一个数组 s 记录对规模为 j 的钢条切割出的第一段钢条的长度 s[j]，即切割位置。
![[Pasted image 20230509111211.png]]
# 3.2 矩阵链乘法
## 1. 问题引入
![[Pasted image 20230518141903.png]]
n 个连续相乘的矩阵构成一个矩阵链<A1, A2,..., An>,计算矩阵链乘积。乘积满足结合律，可以在矩阵间加括号。
不同的加括号方式带来的代价不同
![[Pasted image 20230518142102.png]]
会有很大的差距，我们的目的就是找一个括号方案使矩阵乘法的标量乘法次数最小。

## 2. 求解
### 暴力求解
复杂度为指数级，不可取
### 动态规划求解
1. 结构特征
![[Pasted image 20230518142804.png]]
可以用反证法证明一定成立
2. 递归求解
m 为计算矩阵链 $A_{ij}$ 所需的标量乘法运算次数的最小值。
![[Pasted image 20230518144735.png]]
![[Pasted image 20230518144922.png]]
我们用 s[i, j]记录使 m[i, j]取得最小值的 k。
![[Pasted image 20230518145007.png]]
自底向上便可以求得 m[1, n]
### 时间复杂度
$\Omega(n^3)$
需要 $\theta(n^2)$ 的空间保存 m，s
## 构造最优解
递归输出 s 即可
# 3.3 最长公共子序列
## 1. 问题引入
![[Pasted image 20230518150754.png]]
## 2 求解
![[Pasted image 20230518150930.png]]
看最后一位是否公共，公共则 i，j 同时-1，不然则计算则按公示分别计算两种情况。
# 3.4 总结思想
动态规划是求解决策过程最优化的数学方法，需要问题具备两个要素：
1. 问题的最优解满足最优子结构性质：一个问题的最优解包含其子问题的最优解
2. 具有子问题重叠：自顶向下（自底向上）产生的子问题并不是新问题，有些子问题会被重复计算多次。
动态理解到底优化了哪个部分：
![[Pasted image 20230518150259.png]]
## “剪切-粘贴”（cut-and-paste）技术
一般用反证法证明：假定子问题的解不是其自身的最优解，而存在“更优的解” ，那么我们可以从原问题的解中“剪切”掉这些“最优解”的部分，而将“更优的解”粘贴进去，从而得到原问题的一个“更优”解，这与最初的解是原问题最优解的前提假设相矛盾。因此，不可能存在“更优的解”。反之，原问题的子问题的解应是其自身的最优解——最优子结构性成立。
如最短路径：
![[Pasted image 20230518150442.png]]
## 子问题无关性
能够用动态规划策略求解的问题，构成最优解的子问题间必须是无关的，即：同一个原问题的一个子问题的解不影响另一个子问题的解，最短路径子问题之间是不共享资源的。
![[Pasted image 20230518150536.png]]
## 算法时间和构造方法
**求原问题最优解的代价通常就是子问题最优解的代价再加上由此次选择直接产生的代价。**
![[Pasted image 20230518150634.png]]