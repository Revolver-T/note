# 2.1 分治算法
## 1. 核心思想
将问题分解为若干子问题，然后逐一解决子问题最后和并子问题的解成整体问题的解决
![[Pasted image 20230508101745.png]]
很好地说明了归并的思想和过程
## 2. 归并排序
Merge 函数的伪代码
```c++
Merge(A,p,q,r)
	n1 = q-p+1
	n2 = r-q
	L[1..n1+1] and R[1..n2+1] be new arrays
	for i = 1 to n1
		L[i] = A[p+i-1]
	for j = 1 to n2
		R[j] = A[q+j]
	L[n1+1] = infinity
	R[n2+1] = infinity
	i=1,j=1
	for k = p to r
		if L[i] < R[j]
			A[k] = L[i],i++
		else 
			A[k] = L[j],j++
```
将 Merge 作为子程序来实现归并算法
![[Pasted image 20230508101610.png]]

分治规模实际为 n/2，过程中要注意边界问题
## 3. 分析分治算法
主要是解递归式的问题。主流方法有三种
### （1） 代换法
猜测出界，再用数学归纳法等方法证明
### （2） 递归树法
将递归式转化为树，树中的结点代表不同递归层次付出的代价。使用边界求和的技巧来解递归。
### （3） 主方法
给出递归形式 T(n) = aT(n/b) + f(n) 的界，其中 a ≥ 1 ，b > 1 ，f(n) 是给定的函数。
# 2.2 最大子数组问题
## 1. 问题介绍
![[Pasted image 20230509093714.png]]

## 2. 暴力求解：
尝试所有可能的购买和出售日期对，n 天有 Cn 2 种可能，时间复杂度为 $O(n^2)$
## 3. 分而治之
### 问题转化
我们的目的是寻找一段日期，使得从第一天到最后一天的股票价格净变值最大，我们以新的角度看待问题：考察每日的价格变化。
即，给定一个数组 `A[0..n-1]`，我们的目标是找到 `i` 和 `j`（0 <= i <= j < n），使得子数组 `A[i..j]` 的和最大。

### 解决方法
1. 暴力：使用两层循环遍历数组的所有子数组，计算它们的和并找到最大和。这种方法的时间复杂度是 O(n^2)，在大型数组中效率较低。
2. 分治：将数组分成两个相等大小的子数组，最大子数组要么位于左侧子数组、要么位于右侧子数组，要么跨越两个子数组。使用递归处理左侧和右侧子数组，然后计算跨越两个子数组的最大子数组。三种情况取较大者。这种方法的时间复杂度是 O(nlogn)
 寻找跨中点最大子数组的伪代码如下： 
 总体思路为从中点开始，分别向左向右寻找到最大连续和，记录对应位置的下标与该和，最后返回左右下标和左右总和
 ![[Pasted image 20230509094909.png]]
 此时可以实现分治算法的伪代码：
 它递归地将数组分为两个子数组，并计算左侧子数组、右侧子数组和跨越两个子数组的最大子数组和。最后返回这三者中的最大值。
 ![[Pasted image 20230509095454.png]]
 分析：
 时间复杂度为 $\Theta(nlgn)$
 3. ![[Pasted image 20230509102412.png]]

采用动态规划（DP）的思想可以将最大子数组问题求解的时间复杂度降到线性。  
已知前 n 个数的最大子数组，其和记为 dp[n]，考虑第 n+1 个数。  
若 d[n] + nums[n+1] < nums[n+1]，则 d[n] < 0 ,其最大和为 nums[n+1]本身，此时最大连续数组只有 nums[n+1]一个数。  
若 d[n] + nums[n+1] >= nums[n+1]，则 nums[n+1]是最大子数组一员，将其加入最大子数组

``` c++

    int maxSubArray(vector<int>& nums) {

        int pre = 0, maxAns = nums[0];

        for (const auto &x: nums) {

            pre = max(pre + x, x);

            maxAns = max(maxAns, pre);

        }

        return maxAns;

    }

```


# 2.3 矩阵乘法的 Strassen 乘法