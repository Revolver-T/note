#算法 #最短路径
# 最短路径相关概念和变体
## 相关概念
路的权重和最短路径的精确数学定义
![[Pasted image 20230522225609.png]]
![[Pasted image 20230522225620.png]]
最短路径问题：给出图 G 和源点 s，找出 s 到图 G 中其他所有点的最短路径和最短权值。
## 引理 
最短路径的子路径也是最短的
证明：假设子路径不是最短，那么将更短的子路径替换原子路径，会得到更短的父路径，与最短路径矛盾
![[Pasted image 20230522225849.png]]
## 负边和负环
一个图有负边仍然有最短路径，有负环则定义最短路径为最短路径为 $-\infty$。
Dijkstra 算法假定所有边权值非负，而贝尔曼算法允许负边。如果有负环，算法还能检测出来。
## 最短路径表示
主要是要有一个记录某个点最短路径前驱结点的数组，有了此数组就可以递归输出最短路径了。
![[Pasted image 20230522232020.png]]
这样导出的子图叫最短路径树，最短路径树不唯一。
# 最短路径和松弛的性质
## 最短路径性质
1. 最短路径不可能含有负环或正环
2. 最短路径最大长度为|V|-1
## 松弛（Relaxation）
### 概念
处理方程式的一个方法，由最初的粗略估计时产生的错误在随后的估计时得到逐渐减少直到所有错误都在特定的限制范围之内。
在最短路径中，我们用一个 d[v]维持从源点 s 到 v 的最短路径权重的上界，松弛在这里用来不断减小这个上界（缩紧）。
### 松弛过程
考察 s 到 v 的路径是否可以改善。将 s 到 u 之间的最短路径加上 u 到 v 的最短路径与 s 到 v 的权重比较，如果前者更小，则对 d 和π进行更新。
![[Pasted image 20230522233647.png]]
本章的所有算法都是初始化然后不断进行松弛操作。算法间的区别是对每条边的松弛次数和松弛边的次序不同。如 Dijkstra 对每条边松弛一次，而 Bellman 对每条边松弛|V|-1 次。
### 松弛性质
![[Pasted image 20230522234108.png]]
![[Pasted image 20230522234118.png]]
![[Pasted image 20230522234532.png]]
### 性质证明
1. 三角不等式：假设 s 到 v 有最短路径 p，p 的权值小于等于 s 到 v 的任何一条路径，特殊情况：p 的权小于等于从 s 到 u 的最短路径再加上 uv 的权
2. 上界性质：核心是归纳假设 ![[Pasted image 20230523094207.png]]
3.  无路径性质：![[Pasted image 20230523094351.png]]
4. 收敛性质：最短路径由两段拼凑，当一段最短后，另一短必最短 ![[Pasted image 20230523095011.png]]
5. 路径松弛：用到归纳证明和收敛性质，对 vi-1 同样得出了结论以此得证。 ![[Pasted image 20230523095449.png]]
# 贝尔曼算法
对无负环的图返回最短路径和权重
![[Pasted image 20230524195803.png]]
时间复杂度 $O(VE)$，一共进行 O（V）次，每次对每条边都进行松弛。
# 有向无环图的最短路径（DAG）
对有向无环图进行拓扑排序，然后按排序后结果进行松弛，可以得到 s 到所有节点的最短路径
时间复杂度：$O(V+E)$
# Dijkstra 算法
## 时间复杂度分析
1. 初始化：初始化所有的距离为无穷大（除了起点到自己的距离为0）。这需要 O(V)的时间
2. 主循环：Dijkstra算法的主要部分包含一个循环，该循环继续运行，直到所有节点都已被访问。每次循环，我们做两件事：
    a) 从未访问节点中选择最近的一个。这需要O(V)的时间（在没有优化的情况下），因为我们需要遍历所有未访问的节点才能找到最近的节点。
    b) 对选中的节点，我们更新所有相邻节点的距离。这需要O(E)的时间，其中E是图中边的数量。在最坏的情况下，我们可能需要更新图中所有边上的节点的距离。
所以，主循环的总时间复杂度是 O(V^2+E). 
如果使用堆，情况如下
1. **初始化**：我们将源节点的距离设为0，其余所有节点的距离设为无穷大。这需要 O(V)的时间，其中 V 是图中节点的数量。然后我们将所有节点插入优先队列（实际上是一个二叉堆）。这需要 O(V log V)的时间，因为插入一个元素到二叉堆的时间复杂度为 O(log V)。
2. **主循环**：我们将主循环执行V次，每次都从优先队列中取出一个未访问的节点u，它具有从源节点到该节点的最短距离。从二叉堆中删除最小元素的时间复杂度为O(log V)，所以这个步骤的总时间复杂度为O(V log V)。
    对于每一个节点u，我们还需要检查它的所有邻居，以更新从源节点到邻居节点的距离。假设节点u有E_u个邻居，我们需要E_u次的O(log V)操作来更新堆。因此，处理节点u的时间复杂度为O(E_u log V)。
    考虑到我们需要对所有节点执行这个步骤，即我们需要处理图中的所有边，所以主循环的总时间复杂度为 O(E log V)，其中 E 是图中边的数量。
    综上：O(V log V + E log V) = O((V + E) log V)